// Copyright (c) 2023 IndyKite
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/neo4j/neo4j-go-driver/v5/neo4j (interfaces: ExplicitTransaction,ResultWithContext,SessionWithContext)

// Package test is a generated GoMock package.
package test

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	neo4j "github.com/neo4j/neo4j-go-driver/v5/neo4j"
	db "github.com/neo4j/neo4j-go-driver/v5/neo4j/db"
)

// MockExplicitTransaction is a mock of ExplicitTransaction interface.
type MockExplicitTransaction struct {
	neo4j.ExplicitTransaction
	ctrl     *gomock.Controller
	recorder *MockExplicitTransactionMockRecorder
}

// MockExplicitTransactionMockRecorder is the mock recorder for MockExplicitTransaction.
type MockExplicitTransactionMockRecorder struct {
	mock *MockExplicitTransaction
}

// NewMockExplicitTransaction creates a new mock instance.
func NewMockExplicitTransaction(ctrl *gomock.Controller) *MockExplicitTransaction {
	mock := &MockExplicitTransaction{ctrl: ctrl}
	mock.recorder = &MockExplicitTransactionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockExplicitTransaction) EXPECT() *MockExplicitTransactionMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockExplicitTransaction) Close(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockExplicitTransactionMockRecorder) Close(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockExplicitTransaction)(nil).Close), arg0)
}

// Commit mocks base method.
func (m *MockExplicitTransaction) Commit(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockExplicitTransactionMockRecorder) Commit(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockExplicitTransaction)(nil).Commit), arg0)
}

// Rollback mocks base method.
func (m *MockExplicitTransaction) Rollback(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockExplicitTransactionMockRecorder) Rollback(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockExplicitTransaction)(nil).Rollback), arg0)
}

// Run mocks base method.
func (m *MockExplicitTransaction) Run(arg0 context.Context, arg1 string, arg2 map[string]interface{}) (neo4j.ResultWithContext, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Run", arg0, arg1, arg2)
	ret0, _ := ret[0].(neo4j.ResultWithContext)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Run indicates an expected call of Run.
func (mr *MockExplicitTransactionMockRecorder) Run(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Run", reflect.TypeOf((*MockExplicitTransaction)(nil).Run), arg0, arg1, arg2)
}

// legacy mocks base method.
func (m *MockExplicitTransaction) legacy() neo4j.Transaction {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "legacy")
	ret0, _ := ret[0].(neo4j.Transaction)
	return ret0
}

// legacy indicates an expected call of legacy.
func (mr *MockExplicitTransactionMockRecorder) legacy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "legacy", reflect.TypeOf((*MockExplicitTransaction)(nil).legacy))
}

// MockResultWithContext is a mock of ResultWithContext interface.
type MockResultWithContext struct {
	neo4j.ResultWithContext
	ctrl     *gomock.Controller
	recorder *MockResultWithContextMockRecorder
}

// MockResultWithContextMockRecorder is the mock recorder for MockResultWithContext.
type MockResultWithContextMockRecorder struct {
	mock *MockResultWithContext
}

// NewMockResultWithContext creates a new mock instance.
func NewMockResultWithContext(ctrl *gomock.Controller) *MockResultWithContext {
	mock := &MockResultWithContext{ctrl: ctrl}
	mock.recorder = &MockResultWithContextMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockResultWithContext) EXPECT() *MockResultWithContextMockRecorder {
	return m.recorder
}

// Collect mocks base method.
func (m *MockResultWithContext) Collect(arg0 context.Context) ([]*db.Record, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Collect", arg0)
	ret0, _ := ret[0].([]*db.Record)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Collect indicates an expected call of Collect.
func (mr *MockResultWithContextMockRecorder) Collect(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Collect", reflect.TypeOf((*MockResultWithContext)(nil).Collect), arg0)
}

// Consume mocks base method.
func (m *MockResultWithContext) Consume(arg0 context.Context) (neo4j.ResultSummary, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consume", arg0)
	ret0, _ := ret[0].(neo4j.ResultSummary)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Consume indicates an expected call of Consume.
func (mr *MockResultWithContextMockRecorder) Consume(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockResultWithContext)(nil).Consume), arg0)
}

// Err mocks base method.
func (m *MockResultWithContext) Err() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Err")
	ret0, _ := ret[0].(error)
	return ret0
}

// Err indicates an expected call of Err.
func (mr *MockResultWithContextMockRecorder) Err() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Err", reflect.TypeOf((*MockResultWithContext)(nil).Err))
}

// IsOpen mocks base method.
func (m *MockResultWithContext) IsOpen() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsOpen")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsOpen indicates an expected call of IsOpen.
func (mr *MockResultWithContextMockRecorder) IsOpen() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsOpen", reflect.TypeOf((*MockResultWithContext)(nil).IsOpen))
}

// Keys mocks base method.
func (m *MockResultWithContext) Keys() ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Keys")
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Keys indicates an expected call of Keys.
func (mr *MockResultWithContextMockRecorder) Keys() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Keys", reflect.TypeOf((*MockResultWithContext)(nil).Keys))
}

// Next mocks base method.
func (m *MockResultWithContext) Next(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Next indicates an expected call of Next.
func (mr *MockResultWithContextMockRecorder) Next(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*MockResultWithContext)(nil).Next), arg0)
}

// NextRecord mocks base method.
func (m *MockResultWithContext) NextRecord(arg0 context.Context, arg1 **db.Record) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NextRecord", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// NextRecord indicates an expected call of NextRecord.
func (mr *MockResultWithContextMockRecorder) NextRecord(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NextRecord", reflect.TypeOf((*MockResultWithContext)(nil).NextRecord), arg0, arg1)
}

// Peek mocks base method.
func (m *MockResultWithContext) Peek(arg0 context.Context) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Peek", arg0)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Peek indicates an expected call of Peek.
func (mr *MockResultWithContextMockRecorder) Peek(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Peek", reflect.TypeOf((*MockResultWithContext)(nil).Peek), arg0)
}

// PeekRecord mocks base method.
func (m *MockResultWithContext) PeekRecord(arg0 context.Context, arg1 **db.Record) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeekRecord", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// PeekRecord indicates an expected call of PeekRecord.
func (mr *MockResultWithContextMockRecorder) PeekRecord(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeekRecord", reflect.TypeOf((*MockResultWithContext)(nil).PeekRecord), arg0, arg1)
}

// Record mocks base method.
func (m *MockResultWithContext) Record() *db.Record {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Record")
	ret0, _ := ret[0].(*db.Record)
	return ret0
}

// Record indicates an expected call of Record.
func (mr *MockResultWithContextMockRecorder) Record() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Record", reflect.TypeOf((*MockResultWithContext)(nil).Record))
}

// Single mocks base method.
func (m *MockResultWithContext) Single(arg0 context.Context) (*db.Record, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Single", arg0)
	ret0, _ := ret[0].(*db.Record)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Single indicates an expected call of Single.
func (mr *MockResultWithContextMockRecorder) Single(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Single", reflect.TypeOf((*MockResultWithContext)(nil).Single), arg0)
}

// buffer mocks base method.
func (m *MockResultWithContext) buffer(arg0 context.Context) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "buffer", arg0)
}

// buffer indicates an expected call of buffer.
func (mr *MockResultWithContextMockRecorder) buffer(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "buffer", reflect.TypeOf((*MockResultWithContext)(nil).buffer), arg0)
}

// legacy mocks base method.
func (m *MockResultWithContext) legacy() neo4j.Result {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "legacy")
	ret0, _ := ret[0].(neo4j.Result)
	return ret0
}

// legacy indicates an expected call of legacy.
func (mr *MockResultWithContextMockRecorder) legacy() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "legacy", reflect.TypeOf((*MockResultWithContext)(nil).legacy))
}
